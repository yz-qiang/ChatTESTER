// original test path: /Users/zhi/Documents/PH.D/Project/Testing/ChatTESTER/CodePackage/Prompt2Testing/repo_get/Four_project/GoSimpleLLC_nbvcxz/src/test/java/me/gosimple/nbvcxz/resources/Configuration_ESTest.java
/*
 * This file was automatically generated by EvoSuite
 * Sat Jan 27 03:56:06 GMT 2024
 */
package me.gosimple.nbvcxz.resources;

import org.junit.Test;
import java.util.ResourceBundle;
import static org.junit.Assert.*;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Pattern;
import me.gosimple.nbvcxz.matching.PasswordMatcher;
import me.gosimple.nbvcxz.matching.YearMatcher;
import me.gosimple.nbvcxz.resources.AdjacencyGraph;
import me.gosimple.nbvcxz.resources.Configuration;
import me.gosimple.nbvcxz.resources.Dictionary;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

import org.junit.Test;
import java.util.Locale;
import static org.junit.Assert.*;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Pattern;
import me.gosimple.nbvcxz.matching.PasswordMatcher;
import me.gosimple.nbvcxz.matching.YearMatcher;
import me.gosimple.nbvcxz.resources.AdjacencyGraph;
import me.gosimple.nbvcxz.resources.Configuration;
import me.gosimple.nbvcxz.resources.Dictionary;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

import org.junit.Test;
import static org.junit.Assert.*;
import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Pattern;
import me.gosimple.nbvcxz.matching.PasswordMatcher;
import me.gosimple.nbvcxz.matching.YearMatcher;
import me.gosimple.nbvcxz.resources.AdjacencyGraph;
import me.gosimple.nbvcxz.resources.Configuration;
import me.gosimple.nbvcxz.resources.Dictionary;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class)
@EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false)
public class Configuration_ESTest extends Configuration_ESTest_scaffolding {

    @Test
    public void testGetLocale() {
        // Create a Configuration object
        Configuration configuration = new Configuration(null, null, null, null, null, null, null, null, Locale.US, false, 0);

        // Call the getLocale() method
        Locale result = configuration.getLocale();

        // Assert that the returned locale is not null
        assertNotNull(result);

        // Assert that the returned locale is equal to the expected locale
        assertEquals(Locale.US, result);
    }

@Test
public void testGetDictionaries() {
    List<PasswordMatcher> passwordMatchers = new LinkedList<>();
    Map<String, Long> guessTypes = new HashMap<>();
    List<Dictionary> dictionaries = new LinkedList<>();
    List<AdjacencyGraph> adjacencyGraphs = new LinkedList<>();
    Map<Character, Character[]> leetTable = new HashMap<>();
    Pattern yearPattern = Pattern.compile("me.gosimple.nbvcxz.resources.Configuration");
    Double minimumEntropy = new Double((-1172.9158265564326));
    Integer maxLength = new Integer(1);
    Locale locale = Locale.FRANCE;
    boolean distanceCalc = true;
    long combinationAlgorithmTimeout = 0L;
    Configuration configuration = new Configuration(passwordMatchers, guessTypes, dictionaries, adjacencyGraphs, leetTable, yearPattern, minimumEntropy, maxLength, locale, distanceCalc, combinationAlgorithmTimeout);
    List<Dictionary> result = configuration.getDictionaries();
    
    // Assertion
    assertNotNull(result);
    assertEquals(dictionaries, result);
}

@Test
public void testGetGuessTypes() {
    // Create test data
    List<PasswordMatcher> passwordMatchers = new LinkedList<>();
    List<Dictionary> dictionaries = new LinkedList<>();
    List<AdjacencyGraph> adjacencyGraphs = new LinkedList<>();
    Map<Character, Character[]> leetTable = new HashMap<>();
    Pattern yearPattern = Pattern.compile("");
    Double minimumEntropy = new Double(278.1067);
    Integer maxLength = new Integer(0);
    Locale locale = Locale.SIMPLIFIED_CHINESE;
    boolean distanceCalc = true;
    long combinationAlgorithmTimeout = 0;

    // Create Configuration object
    Configuration configuration = new Configuration(passwordMatchers, null, dictionaries, adjacencyGraphs, leetTable, yearPattern, minimumEntropy, maxLength, locale, distanceCalc, combinationAlgorithmTimeout);

    // Call the focal method
    Map<String, Long> guessTypes = configuration.getGuessTypes();

    // Assert the result
    assertNull(guessTypes);
}

@Test
public void testGetLeetTable() {
    List<PasswordMatcher> passwordMatchers = new LinkedList<>();
    Map<String, Long> guessTypes = new HashMap<>();
    List<Dictionary> dictionaries = new LinkedList<>();
    List<AdjacencyGraph> adjacencyGraphs = new LinkedList<>();
    Map<Character, Character[]> leetTable = new HashMap<>();
    Pattern yearPattern = Pattern.compile("");
    Double minimumEntropy = null;
    Integer maxLength = new Integer(0);
    Locale locale = Locale.getDefault();
    boolean distanceCalc = false;
    long combinationAlgorithmTimeout = 0L;
    Configuration configuration = new Configuration(passwordMatchers, guessTypes, dictionaries, adjacencyGraphs, leetTable, yearPattern, minimumEntropy, maxLength, locale, distanceCalc, combinationAlgorithmTimeout);
    Map<Character, Character[]> result = configuration.getLeetTable();
    
    // Assertion
    assertNotNull(result);
    assertEquals(leetTable, result);
}

@Test
public void testGetFeedbackResource() {
    List<PasswordMatcher> passwordMatchers = new LinkedList<PasswordMatcher>();
    Map<String, Long> guessTypes = new HashMap<String, Long>();
    List<Dictionary> dictionaries = new LinkedList<Dictionary>();
    List<AdjacencyGraph> adjacencyGraphs = new LinkedList<AdjacencyGraph>();
    Map<Character, Character[]> leetTable = new HashMap<Character, Character[]>();
    Pattern yearPattern = Pattern.compile("", 0);
    Double minimumEntropy = new Double(0);
    Integer maxLength = new Integer(0);
    Locale locale = Locale.forLanguageTag("");
    boolean distanceCalc = true;
    long combinationAlgorithmTimeout = 0L;
    
    Configuration configuration = new Configuration(passwordMatchers, guessTypes, dictionaries, adjacencyGraphs, leetTable, yearPattern, minimumEntropy, maxLength, locale, distanceCalc, combinationAlgorithmTimeout);
    
    ResourceBundle expectedResourceBundle = ResourceBundle.getBundle("feedback");

    ResourceBundle actualResourceBundle = configuration.getFeedbackResource();
    assertEquals(expectedResourceBundle, actualResourceBundle);
}

@Test
public void testGetMinimumEntropy() {
    LinkedList<PasswordMatcher> linkedList0 = new LinkedList<PasswordMatcher>();
    LinkedList<Dictionary> linkedList1 = new LinkedList<Dictionary>();
    LinkedList<AdjacencyGraph> linkedList2 = new LinkedList<AdjacencyGraph>();
    HashMap<Character, Character[]> hashMap0 = new HashMap<Character, Character[]>();
    Pattern pattern0 = Pattern.compile("");
    Double double0 = new Double(278.1067);
    Integer integer0 = new Integer(0);
    Locale locale0 = Locale.SIMPLIFIED_CHINESE;
    Configuration configuration = new Configuration(linkedList0, null, linkedList1, linkedList2, hashMap0, pattern0, double0, integer0, locale0, true, 0);

    Double minimumEntropy = configuration.getMinimumEntropy();

    assertNotNull(minimumEntropy);
    assertEquals(278.1067, minimumEntropy, 0.001);
}

@Test
public void testIsDistanceCalc() {
    List<PasswordMatcher> passwordMatchers = new LinkedList<>();
    Map<String, Long> guessTypes = new HashMap<>();
    List<Dictionary> dictionaries = new LinkedList<>();
    List<AdjacencyGraph> adjacencyGraphs = new LinkedList<>();
    Map<Character, Character[]> leetTable = new HashMap<>();
    Pattern yearPattern = Pattern.compile("");
    Double minimumEntropy = new Double(278.1067);
    Integer maxLength = new Integer(0);
    Locale locale = Locale.SIMPLIFIED_CHINESE;
    Configuration configuration = new Configuration(passwordMatchers, guessTypes, dictionaries, adjacencyGraphs, leetTable, yearPattern, minimumEntropy, maxLength, locale, true, 0);

    boolean result = configuration.isDistanceCalc();

    assertTrue(result);
}

@Test
public void testGetAdjacencyGraphs() {
    // Create test data
    List<PasswordMatcher> passwordMatchers = new LinkedList<>();
    Map<String, Long> guessTypes = new HashMap<>();
    List<Dictionary> dictionaries = new LinkedList<>();
    List<AdjacencyGraph> adjacencyGraphs = new LinkedList<>();
    Map<Character, Character[]> leetTable = new HashMap<>();
    Pattern yearPattern = null;
    Double minimumEntropy = null;
    Integer maxLength = new Integer(0);
    Locale locale = Locale.getDefault();
    boolean distanceCalc = false;
    long combinationAlgorithmTimeout = 0L;
    
    // Create Configuration object
    Configuration configuration = new Configuration(passwordMatchers, guessTypes, dictionaries, adjacencyGraphs, leetTable, yearPattern, minimumEntropy, maxLength, locale, distanceCalc, combinationAlgorithmTimeout);
    
    // Call the focal method
    List<AdjacencyGraph> result = configuration.getAdjacencyGraphs();
    
    // Assert the result
    assertEquals(adjacencyGraphs, result);
}

}
